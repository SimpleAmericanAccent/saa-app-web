generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  createdAt DateTime @default(now())
  auth0Id   String?  @unique
  name      String?
  role      String?
  audios    Audio[]  @relation("UserAudios")
}

model Audio {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  duration  Float
  updatedAt DateTime @updatedAt
  url       String
  words     Word[]
  users     User[]   @relation("UserAudios")
}

model Word {
  id            Int                @id @default(autoincrement())
  audioId       Int?
  createdAt     DateTime           @default(now())
  updatedAt     DateTime           @updatedAt
  word          String             @unique
  audio         Audio?             @relation(fields: [audioId], references: [id])
  issues        Issue[]            @relation("IssueToWord")
  consonants    ConsonantPhoneme[] @relation("WordConsonants")
  pronunciation LexicalSet[]       @relation("WordPronunciation")
}

model Issue {
  id        Int      @id @default(autoincrement())
  name      String
  featureId Int
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  feature   Feature  @relation(fields: [featureId], references: [id])
  words     Word[]   @relation("IssueToWord")
}

model Feature {
  id     Int     @id @default(autoincrement())
  name   String
  type   String?
  order  Int?
  issues Issue[]
}

model DictionaryEntry {
  id         Int             @id @default(autoincrement())
  word       String          @unique
  createdAt  DateTime        @default(now())
  updatedAt  DateTime        @updatedAt
  notes      String?
  usages     WordUsage[]
  variations WordVariation[]
}

model WordUsage {
  id                Int                     @id @default(autoincrement())
  entryId           Int
  partOfSpeech      String
  meaning           String
  consonantPhonemes ConsonantPhonemeUsage[]
  examples          Example[]
  lexicalSets       LexicalSetUsage[]
  pronunciations    Pronunciation[]
  spellingPatterns  SpellingPattern[]
  entry             DictionaryEntry         @relation(fields: [entryId], references: [id], onDelete: Cascade)
}

model Pronunciation {
  id        Int       @id @default(autoincrement())
  usageId   Int
  phonemic  String?
  broadIPA  String?
  narrowIPA String?
  audioUrl  String?
  speaker   String?
  dialect   String?
  isPrimary Boolean   @default(false)
  notes     String?
  order     Int?      @default(0)
  wordUsage WordUsage @relation(fields: [usageId], references: [id], onDelete: Cascade)
}

model WordVariation {
  id        Int             @id @default(autoincrement())
  entryId   Int
  form      String
  type      String
  isRegular Boolean
  notes     String?
  entry     DictionaryEntry @relation(fields: [entryId], references: [id], onDelete: Cascade)
}

model SpellingPattern {
  id          Int       @id @default(autoincrement())
  usageId     Int
  pattern     String
  type        String
  description String?
  order       Int?
  wordUsage   WordUsage @relation(fields: [usageId], references: [id], onDelete: Cascade)
}

model LexicalSet {
  id          Int               @id @default(autoincrement())
  name        String            @unique
  description String?
  order       Int?
  category    String?
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @default(now()) @updatedAt
  usages      LexicalSetUsage[]
  words       Word[]            @relation("WordPronunciation")
}

model LexicalSetUsage {
  id           Int        @id @default(autoincrement())
  lexicalSetId Int
  usageId      Int
  order        Int?
  lexicalSet   LexicalSet @relation(fields: [lexicalSetId], references: [id], onDelete: Cascade)
  wordUsage    WordUsage  @relation(fields: [usageId], references: [id], onDelete: Cascade)

  @@unique([lexicalSetId, usageId])
}

model Example {
  id         Int       @id @default(autoincrement())
  usageId    Int
  sentence   String
  context    String?
  difficulty String?
  tags       String[]
  wordUsage  WordUsage @relation(fields: [usageId], references: [id], onDelete: Cascade)
}

model ConsonantPhoneme {
  id          Int                     @id @default(autoincrement())
  name        String                  @unique
  description String?
  order       Int?
  category    String?
  createdAt   DateTime                @default(now())
  updatedAt   DateTime                @default(now()) @updatedAt
  usages      ConsonantPhonemeUsage[]
  words       Word[]                  @relation("WordConsonants")
}

model ConsonantPhonemeUsage {
  id                 Int              @id @default(autoincrement())
  consonantPhonemeId Int
  usageId            Int
  order              Int?
  consonantPhoneme   ConsonantPhoneme @relation(fields: [consonantPhonemeId], references: [id], onDelete: Cascade)
  wordUsage          WordUsage        @relation(fields: [usageId], references: [id], onDelete: Cascade)

  @@unique([consonantPhonemeId, usageId])
}