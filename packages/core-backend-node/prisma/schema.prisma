generator client {
  provider = "prisma-client-js"
  output = "generated"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id         String   @id @default(uuid()) @map("user_id")
  auth0Id    String?  @unique              @map("auth0_id") // e.g. "auth0|abc" or "google-oauth2|123"
  email      String                       // optional, for convenience
  name       String?                       // optional
  role       String?
  createdAt  DateTime @default(now())      @map("created_at")
  lastSeenAt DateTime @default(now())      @map("last_seen_at")
  audios     Audio[]  @relation("UserAudios")
  trials     Trial[]
  settings   UserSettings?
}

model Audio {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  duration  Float
  updatedAt DateTime @updatedAt
  url       String
  words     Word[]
  users     User[]   @relation("UserAudios")
}

model Word {
  id            Int                @id @default(autoincrement())
  audioId       Int?
  createdAt     DateTime           @default(now())
  updatedAt     DateTime           @updatedAt
  word          String             @unique
  audio         Audio?             @relation(fields: [audioId], references: [id])
  issues        Issue[]            @relation("IssueToWord")
  consonants    ConsonantPhoneme[] @relation("WordConsonants")
  pronunciation LexicalSet[]       @relation("WordPronunciation")
}

model Issue {
  id        Int      @id @default(autoincrement())
  name      String
  featureId Int
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  feature   Feature  @relation(fields: [featureId], references: [id])
  words     Word[]   @relation("IssueToWord")
}

model Feature {
  id     Int     @id @default(autoincrement())
  name   String
  type   String?
  order  Int?
  issues Issue[]
}

model DictionaryEntry {
  id         Int             @id @default(autoincrement())
  word       String          @unique
  createdAt  DateTime        @default(now())
  updatedAt  DateTime        @updatedAt
  notes      String?
  usages     WordUsage[]
  variations WordVariation[]
}

model WordUsage {
  id                Int                     @id @default(autoincrement())
  entryId           Int
  partOfSpeech      String
  meaning           String
  consonantPhonemes ConsonantPhonemeUsage[]
  examples          Example[]
  lexicalSets       LexicalSetUsage[]
  pronunciations    Pronunciation[]
  spellingPatterns  SpellingPattern[]
  entry             DictionaryEntry         @relation(fields: [entryId], references: [id], onDelete: Cascade)
}

model Pronunciation {
  id        Int       @id @default(autoincrement())
  usageId   Int
  phonemic  String?
  broadIPA  String?
  narrowIPA String?
  audioUrl  String?
  speaker   String?
  dialect   String?
  isPrimary Boolean   @default(false)
  notes     String?
  order     Int?      @default(0)
  wordUsage WordUsage @relation(fields: [usageId], references: [id], onDelete: Cascade)
}

model WordVariation {
  id        Int             @id @default(autoincrement())
  entryId   Int
  form      String
  type      String
  isRegular Boolean
  notes     String?
  entry     DictionaryEntry @relation(fields: [entryId], references: [id], onDelete: Cascade)
}

model SpellingPattern {
  id          Int       @id @default(autoincrement())
  usageId     Int
  pattern     String
  type        String
  description String?
  order       Int?
  wordUsage   WordUsage @relation(fields: [usageId], references: [id], onDelete: Cascade)
}

model LexicalSet {
  id          Int               @id @default(autoincrement())
  name        String            @unique
  description String?
  order       Int?
  category    String?
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @default(now()) @updatedAt
  usages      LexicalSetUsage[]
  words       Word[]            @relation("WordPronunciation")
}

model LexicalSetUsage {
  id           Int        @id @default(autoincrement())
  lexicalSetId Int
  usageId      Int
  order        Int?
  lexicalSet   LexicalSet @relation(fields: [lexicalSetId], references: [id], onDelete: Cascade)
  wordUsage    WordUsage  @relation(fields: [usageId], references: [id], onDelete: Cascade)

  @@unique([lexicalSetId, usageId])
}

model Example {
  id         Int       @id @default(autoincrement())
  usageId    Int
  sentence   String
  context    String?
  difficulty String?
  tags       String[]
  wordUsage  WordUsage @relation(fields: [usageId], references: [id], onDelete: Cascade)
}

model ConsonantPhoneme {
  id          Int                     @id @default(autoincrement())
  name        String                  @unique
  description String?
  order       Int?
  category    String?
  createdAt   DateTime                @default(now())
  updatedAt   DateTime                @default(now()) @updatedAt
  usages      ConsonantPhonemeUsage[]
  words       Word[]                  @relation("WordConsonants")
}

model ConsonantPhonemeUsage {
  id                 Int              @id @default(autoincrement())
  consonantPhonemeId Int
  usageId            Int
  order              Int?
  consonantPhoneme   ConsonantPhoneme @relation(fields: [consonantPhonemeId], references: [id], onDelete: Cascade)
  wordUsage          WordUsage        @relation(fields: [usageId], references: [id], onDelete: Cascade)

  @@unique([consonantPhonemeId, usageId])
}

model OrthoWord {
  id            Int             @id @default(autoincrement())
  word          String          @unique
  freqSubtlexUs Int?
  pronsCmuDict  PronCmuDict[]
}

model PronCmuDict {
  id           Int         @id @default(autoincrement())
  orthoWordId  Int
  pronCmuDict  String
  orthoWord    OrthoWord   @relation(fields: [orthoWordId], references: [id])

  @@unique([orthoWordId, pronCmuDict])
}

// Quiz-related models - Using ChatGPT's improved approach
enum Side {
  A
  B
}

model Contrast {
  id            String  @id @default(uuid())     @map("contrast_id")
  key           String  @unique                  @map("key")         // e.g. "KIT_FLEECE" (your QUIZ_TYPE_IDS)
  name          String                           @map("name")        // "KIT vs FLEECE"
  title         String                           @map("title")       // "KIT vs FLEECE Minimal Pairs Quiz"
  description   String?                          @map("description") // "sick vs seek"
  category      String                           @map("category")    // "vowels" | "consonants" (keep string for MVP)
  soundAName    String                           @map("sound_a_name") // "KIT"
  soundBName    String                           @map("sound_b_name") // "FLEECE"
  soundASymbol  String?                          @map("sound_a_symbol") // "[Éª]"
  soundBSymbol  String?                          @map("sound_b_symbol") // "[i]"
  active        Boolean @default(true)

  pairs         Pair[]

  @@map("contrast")
}

model Pair {
  pairId      String   @id @default(uuid()) @map("pair_id")
  contrastId  String   @map("contrast_id")
  wordA       String   @map("word_a")
  wordB       String   @map("word_b")
  alternateA  String[] @map("alternate_a")       // Homophones for wordA (same pronunciation, different spellings)
  alternateB  String[] @map("alternate_b")       // Homophones for wordB (same pronunciation, different spellings)
  audioAUrl   String   @map("audio_a_url")
  audioBUrl   String   @map("audio_b_url")
  active      Boolean  @default(true)
  contrast    Contrast @relation(fields: [contrastId], references: [id], onDelete: Restrict)
  trials      Trial[]
  @@unique([contrastId, wordA, wordB], name: "uq_pair_in_contrast") // prevents duplicates inside a contrast
  @@map("pair")
}

model Trial {
  trialId       String   @id @map("trial_id")  // client UUID for idempotency
  userId        String   @map("user_id")       // our UUID, not Auth0's sub
  pairId        String   @map("pair_id")
  presentedSide Side     @map("presented_side") // "A" or "B"
  choiceSide    Side     @map("choice_side")    // "A" or "B"
  isCorrect     Boolean  @map("is_correct")
  presentedAt   DateTime @map("presented_at")
  respondedAt   DateTime @map("responded_at")
  latencyMs     Int      @map("latency_ms")
  pair          Pair     @relation(fields: [pairId], references: [pairId], onDelete: Restrict)
  user          User     @relation(fields: [userId], references: [id], onDelete: Restrict)
  @@index([userId, presentedAt(sort: Desc)], name: "ix_user_time")
  @@index([userId, pairId, presentedAt(sort: Desc)], name: "ix_user_pair_time")
  @@map("trial")
}

model UserSettings {
  id           String   @id @default(uuid()) @map("user_settings_id")
  userId       String   @unique @map("user_id")
  quizSettings Json     @map("quiz_settings") // Store quiz preferences as JSON
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @default(now()) @updatedAt @map("updated_at")
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  @@map("user_settings")
}